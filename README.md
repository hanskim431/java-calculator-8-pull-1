# java-calculator-precourse
본 repository는 우아한테크코스(Woowa Tech Course) 웹 백엔드 8기의 프리코스 1주차 과제입니다.

## 학습 목표
본 과제의 기본 학습 목표는 Git, GitHub, IDE 등 실제 개발 환경에 익숙해지고,  
교육 과정에서 사용하는 프로그래밍 언어를 통해 간단한 문제를 해결하는 것입니다.  

추가적으로 설정한 개인 목표는 다음과 같습니다.

1. **요구사항 완전 구현**  
   - 주어진 요구사항을 면밀히 분석하고, 모든 기능 명세를 빠짐없이 구현합니다.  
   - 작은 요구라도 누락되지 않도록 세부 명세 단위로 구현 및 검증을 진행합니다.
2. **객체지향 설계 및 MVC 구조 적용**  
   - 핵심 도메인을 역할별로 분리하여 (`Calculator`, `Positive`, `Delimiter` 등) [객체지향 생활 체조 원칙](https://jaehoney.tistory.com/343)에 따라 설계합니다.  
   - 입력, 처리, 출력의 책임을 명확히 구분한 MVC 구조를 적용하여 유지보수성과 확장성을 높입니다.
3. **테스트 주도 개발(TDD) 실천**  
   - 기능별 테스트를 우선 작성하고, 테스트를 통과시키는 방식으로 구현을 진행합니다.  
   - 각 기능은 README의 기능 목록 단위로 커밋하며,  
     커밋 메시지는 [Angular 스타일 컨벤션](https://gist.github.com/stephenparish/9941e89d80e2bc58a153)을 준수합니다.

## 기능 목록
- [x] 문자열 입력 - 사용자의 문자열을 입력 받는다.
- [x] 문자열 출력 - 프로그램의 결과를 출력한다.
- [x] 문자열 파싱 - 입력된 문자열을 구분자와 자연수로 파싱한다.
- [x] 양수 합산 - 파싱된 양수의 합을 계산한다.
- [x] 공백 처리 - 입력된 문자열이 없으면 0을 출력한다.
- [x] 음수 검증 - 양수가 아닌 숫자일 때 예외를 발생시킨다.
- [x] 잘못 된 구분자(문자) 검증 - 구분자로 등록되지 않은 문자를 사용하면 예외를 발생시킨다.
- [x] 연속된 구분자 사용 검증 - 사용자가 구분자 사이에 숫자를 입력하지 않을 때 예외를 발생시킨다.
- [x] 커스텀 구분자 등록 - 문자열 앞부분의 "//"와 "\n" 을 사용해 커스텀 구분자를 등록한다.
- [x] 커스텀 구분자 등록 검증 - 기본 구분자, 숫자, 문자열을 커스텀 구분자로 등록할 경우 예외를 발생시킨다.
- [x] 커스텀 구분자 문자열 파싱 - 입력된 문자열을 기본+커스텀 구분자와 자연수로 파싱한다.

## 고려사항
- **자연수 사용 이유**
  - 부동 소수점 연산의 정밀도 문제 회피
  - 요구사항의 단순성과 명확성 유지
  - 객체지향 설계 및 TDD 연습에 집중
- **연속된 구분자를 허용하지 않는 이유**
  - "구분자를 기준으로 분리한 각 숫자의 합을 반환한다."라는 요구사항을 반영
  - 공백(미입력)은 숫자가 아니기에 공백을 불허 
    
## 허용 사항
- 구분자와 숫자가 모두 없는 입력을 허용합니다.
- 기본 구분자와 커스텀 구분자를 동시에 사용할 수 있습니다.
- 커스텀 구분자로 공백(`" "`)을 사용할 수 있습니다.

## 실패 케이스
사용자가 잘못된 값을 입력할 경우 `IllegalArgumentException`을 발생시키며, 애플리케이션은 종료됩니다.
예측 가능한 동작을 위해, 사용자가 혼동할 수 있는 입력 사례를 포함시켰습니다.

### 구분자
- 사용자가 커스텀 구분자로 선언되지 않은 문자를 사용할 때 예외 발생

### 숫자
- 사용자가 음수를 입력할 때 예외 발생  
  - 단, `-`가 커스텀 구분자로 선언된 경우는 제외
- 사용자가 소수점이 포함된 숫자(소수)를 입력할 때
- 사용자가 구분자 사이에 숫자를 입력하지 않을 때

### 커스텀 구분자
- 기본 구분자(쉼표, 콜론)를 커스텀 구분자로 선언할 때
- 숫자를 커스텀 구분자로 선언할 때
- 문자가 아닌 문자열을 커스텀 구분자로 선언할 때
- `//\n`이 문자열의 앞부분이 아닌 다른 위치에 사용될 때

## 회고
### 느낀 점
#### 기능의 단위
이번 미션의 과제 진행 요구사항에는 '기능 목록'을 만들고 '기능 단위'로 커밋을 하는 방식을 요구하였습니다.
되돌아보니 제가 평소 하던 커밋의 단위는 대부분 '구현'을 중심으로 따로 목록을 작성하지 않았고, 큰 단위의 비즈니스 로직이 하나의 커밋에 담겼던 것 같습니다. 
마치 문서 작성 중 수시로하는 save처럼 코드의 '버전 관리'의 목적 보다는 '코드 저장'을 반복하는 커밋이나, '소셜 로그인 기능 구현', '회원 정보 수정 기능 구현' 처럼 크고 명확한 기능 단위로 커밋하였습니다.

이번 과제에서는 '덧셈 계산기'라는 매우 간단한 목표를 지닌 프로그램으로 "평소처럼 커밋을 쓴다면 커밋의 크기가 커 제대로 된 기능 명세를 할 수 없겠다."라는 고민을 가지고 기능 단위를 나누었습니다.
어떻게 설정해야 구현 단계에서 자연스럽게 기능 단위 커밋이 작성될 지, 또 기능의 크기을 얼마나 크게 설정해야 너무 잦은 커밋을 하거나, 혹은 문제가 생겨 revert를 때 너무 많은 코드를 잃지 않을 지 고민하였습니다. 

고민 끝에 객체 지향 원칙에 따라 책임별로 객체를 구분하고, 책임을 하나의 기능이 되로록 설정하였습니다. 입/출력, 파싱, 합산, 검증, 커스텀 등을 각각 수행하는 객체를 구현할 수 있도록 기능 목록을 작성하였습니다.
문제는 '객체의 구현'에 초점이 맞춰져 있다보니, 사용자 관점에서의 '기능'에는 조금 동떨어진 기능 목록이었습니다. 
때문에 커밋마다 구현되는 기능의 크기가 불균형을 이루게 되었고, 구현 순서 역시 제가 처음 계획했던 것과는 달리 순서가 꼬이거나 여러 기능을 한 커밋에 구현해야하는 등 기능 구현을 누락시킬 수 있는 상황을 마주하였습니다.

다음부터는 이런 문제를 보완하고자, 사용자를 기준으로 사용자 스토리 관점에서 기능 목록을 설계하고, 큰 기능이 있다면 그것을 세분화하여 기능 목록을 작성할 것입니다.

#### 개인 학습 목표
이번 과제를 수행하며 테크코스의 학습 목표와 동시에 제 개인의 학습 목표를 추가로 설정하였습니다. 

첫째, 주어진 요구사항을 꼼꼼하게 읽고 작은 요구라도 누락되지 않게 구현하는 요구 사항의 완전 구현입니다. 테크코스의 과제 진행 방식에 적응 하고 모든 기능 명세를 빠뜨리지 않고자하였습니다.   
둘째, 객체 지향 설계 OOP와 테스트 주도 개발 TDD를 도입했습니다. 차후 진행할 OOP와 TDD를 미리 간단한 과제로 연습하고자 하였습니다.

모든 기능 명세를 빠뜨리지 않기 위해 기능 목록을 TOOD 리스트 형태로 작성하였고, 허용 케이스와 실패 케이스를 나열해 예외 처리의 누락을 줄이고자 하였습니다.
실제 구현 단계에서는 예상했던 것과 달리 구현 순서가 꼬였고, 이때 TODO 리스트가 적잖게 도움되었습니다. 기능 단위를 나누는 훈련과 함께 더불어 기능 목록의 형태도 가다듬어 갈 것입니다.

프로그램의 목표가 크지 않았던 만큼 객체 지향 설계와 테스트 주도 개발도 같이 도입하여 연습하였습니다. 

객체 지향 설계로 프로그램을 구현하니 OOP가 확장에 매우 유리함을 느꼈습니다.
기본 구분자로 계산이 되는 기능을 구현한 뒤 커스텀 구분자 기능을 추가할 때, 이전에 구현했던 로직에 크게 손대지 않고 확장할 수 있었습니다.
절자적 프로그래밍으로 구현했다면, 파싱 로직을 크게 수정해야 했을테지만 간단히 메서드 몇 개만 추가하여 구현과 디버깅에서 공수가 크게 줄었습니다.

### 배운 점
stream 예외 처리 
   
#### Java의 매개변수 전달 방식
메서드 내부에서 매개변수로 받은 String을 다른 값으로 변경했는데, 원본 변수는 그대로였습니다. Java가 참조 전달이라고 배웠는데 왜 안 바뀌는지 이해가 안 갔습니다.

```
private void parseInputText(String inputText, ...) {
    checkCustomDelimiter(inputText, delimiter);
}

private void checkCustomDelimiter(String inputText, Delimiter delimiter) {
    inputText = split[1];  // 이렇게 바꿔도 원본은 안 바뀜!
}
```

checkCustomDelimiter 메서드에서 inputText를 변경했는데, 호출한 parseInputText에서는 값이 변경되지 않았습니다.

문제의 원인은 두가지로 복합적이었습니다. "Java에서 매개변수 전달 방식이 pass by value", "String은 불변" 이 두 원인이 작용하였습니다.

첫째, checkCustomDelimiter 메서드의 inputText 변수는 parseInputText 메서드의 inputText 변수와는 같은 주소를 참조하는 다른 변수입니다.
둘째, `inputText = split[1];`를 통해 재할당 하면 checkCustomDelimiter의 inputText 변수의 참조가 바뀔 뿐 parseInputText 메서드의 inputText 변수는 변하지 않습니다.

이렇게 원본 inputText가 바뀌지 않는 문제를 해결하고자 checkCustomDelimiter 메서드에서 inputText를 반환하여 parseInputText의 inputText에 재할당하도록 수정하였습니다.

#### Java의 불변 객체, 불변 자료형
객체를 다루다보니 값이 바뀌지 않거나 객체의 수정이 불가능한 문제를 겪었고, 객체에서 반환한 값의 오염에 대해 걱정이 들었습니다.

1. `Arrays.stream().toList()`로 만든 List에 add시 `UnsupportedOperationException`가 발생하였습니다. List 자료형인데 왜 add가 되지 않는 지 이해가 안갔습니다.
2. 객체를 반환할 때 외부에서 수정할 수 있으므로 방어적 복사를 해야 한다고 배웠는데, Long도 객체이므로 복사가 필요한지 궁금했습니다.

해당 자료형들이 불변 객체, 불변 자료형인 것을 알았습니다.
Long 등 Wapper 클래스는 불변 객체라 외부에서 수정이 불가능 하다는 것을 알았습니다. 때문에 `new Long(number)`와 같이 방어적 복사는 불필요하다는 것을 알 수 있었습니다.
`toList()`로 만든 List 역시 수정 불가능한 `Immutable List`인 것을 알 수 있었습니다. 이를 해결하기 위해서 `new ArrayList()`를 통해 가변 리스트를 만들어야 한다는 것을 알게 되었습니다.

### 많은 시간을 투자한 부분
개발 과정에서 완벽한 코드와 이상적인 커밋 단위를 추구하다 보니, 비효율적인 작업에 많은 시간을 소모하였습니다. 

작은 코드 변경에도 `git commit --amend`로 기존 커밋을 번복하고 다시 커밋하는 등 지속적인 리팩터링에 대한 욕심이 발목을 잡았습니다. 더 나아가 만족스럽지 않은 코드 구조와 커밋 단위로 인한 좌절감에 프로젝트를 아예 처음부터 다시 시작하기도 했습니다.

이러한 접근 방식의 심각한 비효율성을 깨달은 후, 멘토님의 "많은 개발자들은 구현 중 리팩터링 욕구로 인해 완성에 어려움을 겪는다"는 조언을 떠올렸습니다. 이를 계기로 완벽함을 추구하기보다는 점진적 개선에 집중하는 것으로 개발 방향을 전환하였습니다.
